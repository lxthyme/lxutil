{"version":3,"file":"reportingobserver.min.js","sources":["../../utils/src/polyfill.ts","../../utils/src/error.ts","../../utils/src/misc.ts","../../utils/src/logger.ts","../../utils/src/syncpromise.ts","../src/reportingobserver.ts","../../utils/src/supports.ts"],"sourcesContent":["export const setPrototypeOf =\n  Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties); // tslint:disable-line:no-unbound-method\n\n/**\n * setPrototypeOf polyfill using __proto__\n */\nfunction setProtoOf<TTarget extends object, TProto>(obj: TTarget, proto: TProto): TTarget & TProto {\n  // @ts-ignore\n  obj.__proto__ = proto;\n  return obj as TTarget & TProto;\n}\n\n/**\n * setPrototypeOf polyfill using mixin\n */\nfunction mixinProperties<TTarget extends object, TProto>(obj: TTarget, proto: TProto): TTarget & TProto {\n  for (const prop in proto) {\n    if (!obj.hasOwnProperty(prop)) {\n      // @ts-ignore\n      obj[prop] = proto[prop];\n    }\n  }\n\n  return obj as TTarget & TProto;\n}\n","import { setPrototypeOf } from './polyfill';\n\n/** An error emitted by Sentry SDKs and related utilities. */\nexport class SentryError extends Error {\n  /** Display name of this error instance. */\n  public name: string;\n\n  public constructor(public message: string) {\n    super(message);\n\n    // tslint:disable:no-unsafe-any\n    this.name = new.target.prototype.constructor.name;\n    setPrototypeOf(this, new.target.prototype);\n  }\n}\n","import { Event, Integration, Mechanism, WrappedFunction } from '@sentry/types';\n\n/** Internal */\ninterface SentryGlobal {\n  Sentry?: {\n    Integrations?: Integration[];\n  };\n  SENTRY_ENVIRONMENT?: string;\n  SENTRY_DSN?: string;\n  SENTRY_RELEASE?: {\n    id?: string;\n  };\n  __SENTRY__: {\n    globalEventProcessors: any;\n    hub: any;\n    logger: any;\n  };\n}\n\n/**\n * Requires a module which is protected _against bundler minification.\n *\n * @param request The module path to resolve\n */\nexport function dynamicRequire(mod: any, request: string): any {\n  // tslint:disable-next-line: no-unsafe-any\n  return mod.require(request);\n}\n\n/**\n * Checks whether we're in the Node.js or Browser environment\n *\n * @returns Answer to given question\n */\nexport function isNodeEnv(): boolean {\n  // tslint:disable:strict-type-predicates\n  return Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\n}\n\nconst fallbackGlobalObject = {};\n\n/**\n * Safely get global scope object\n *\n * @returns Global scope object\n */\nexport function getGlobalObject<T>(): T & SentryGlobal {\n  return (isNodeEnv()\n    ? global\n    : typeof window !== 'undefined'\n    ? window\n    : typeof self !== 'undefined'\n    ? self\n    : fallbackGlobalObject) as T & SentryGlobal;\n}\n// tslint:enable:strict-type-predicates\n\n/**\n * Extended Window interface that allows for Crypto API usage in IE browsers\n */\ninterface MsCryptoWindow extends Window {\n  msCrypto?: Crypto;\n}\n\n/**\n * UUID4 generator\n *\n * @returns string Generated UUID4.\n */\nexport function uuid4(): string {\n  const global = getGlobalObject() as MsCryptoWindow;\n  const crypto = global.crypto || global.msCrypto;\n\n  if (!(crypto === void 0) && crypto.getRandomValues) {\n    // Use window.crypto API if available\n    const arr = new Uint16Array(8);\n    crypto.getRandomValues(arr);\n\n    // set 4 in byte 7\n    // tslint:disable-next-line:no-bitwise\n    arr[3] = (arr[3] & 0xfff) | 0x4000;\n    // set 2 most significant bits of byte 9 to '10'\n    // tslint:disable-next-line:no-bitwise\n    arr[4] = (arr[4] & 0x3fff) | 0x8000;\n\n    const pad = (num: number): string => {\n      let v = num.toString(16);\n      while (v.length < 4) {\n        v = `0${v}`;\n      }\n      return v;\n    };\n\n    return (\n      pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7])\n    );\n  }\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    // tslint:disable-next-line:no-bitwise\n    const r = (Math.random() * 16) | 0;\n    // tslint:disable-next-line:no-bitwise\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nexport function parseUrl(\n  url: string,\n): {\n  host?: string;\n  path?: string;\n  protocol?: string;\n  relative?: string;\n} {\n  if (!url) {\n    return {};\n  }\n\n  const match = url.match(/^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nexport function getEventDescription(event: Event): string {\n  if (event.message) {\n    return event.message;\n  }\n  if (event.exception && event.exception.values && event.exception.values[0]) {\n    const exception = event.exception.values[0];\n\n    if (exception.type && exception.value) {\n      return `${exception.type}: ${exception.value}`;\n    }\n    return exception.type || exception.value || event.event_id || '<unknown>';\n  }\n  return event.event_id || '<unknown>';\n}\n\n/** JSDoc */\ninterface ExtensibleConsole extends Console {\n  [key: string]: any;\n}\n\n/** JSDoc */\nexport function consoleSandbox(callback: () => any): any {\n  const global = getGlobalObject<Window>();\n  const levels = ['debug', 'info', 'warn', 'error', 'log', 'assert'];\n\n  if (!('console' in global)) {\n    return callback();\n  }\n\n  const originalConsole = global.console as ExtensibleConsole;\n  const wrappedLevels: { [key: string]: any } = {};\n\n  // Restore all wrapped console methods\n  levels.forEach(level => {\n    if (level in global.console && (originalConsole[level] as WrappedFunction).__sentry__) {\n      wrappedLevels[level] = (originalConsole[level] as WrappedFunction).__sentry_wrapped__;\n      originalConsole[level] = (originalConsole[level] as WrappedFunction).__sentry_original__;\n    }\n  });\n\n  // Perform callback manipulations\n  const result = callback();\n\n  // Revert restoration to wrapped state\n  Object.keys(wrappedLevels).forEach(level => {\n    originalConsole[level] = wrappedLevels[level];\n  });\n\n  return result;\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @param mechanism Mechanism of the exception.\n * @hidden\n */\nexport function addExceptionTypeValue(\n  event: Event,\n  value?: string,\n  type?: string,\n  mechanism: Mechanism = {\n    handled: true,\n    type: 'generic',\n  },\n): void {\n  event.exception = event.exception || {};\n  event.exception.values = event.exception.values || [];\n  event.exception.values[0] = event.exception.values[0] || {};\n  event.exception.values[0].value = event.exception.values[0].value || value || '';\n  event.exception.values[0].type = event.exception.values[0].type || type || 'Error';\n  event.exception.values[0].mechanism = event.exception.values[0].mechanism || mechanism;\n}\n","import { consoleSandbox, getGlobalObject } from './misc';\n\n// TODO: Implement different loggers for different environments\nconst global = getGlobalObject<Window | NodeJS.Global>();\n\n/** Prefix for logging strings */\nconst PREFIX = 'Sentry Logger ';\n\n/** JSDoc */\nclass Logger {\n  /** JSDoc */\n  private _enabled: boolean;\n\n  /** JSDoc */\n  public constructor() {\n    this._enabled = false;\n  }\n\n  /** JSDoc */\n  public disable(): void {\n    this._enabled = false;\n  }\n\n  /** JSDoc */\n  public enable(): void {\n    this._enabled = true;\n  }\n\n  /** JSDoc */\n  public log(...args: any[]): void {\n    if (!this._enabled) {\n      return;\n    }\n    consoleSandbox(() => {\n      global.console.log(`${PREFIX}[Log]: ${args.join(' ')}`); // tslint:disable-line:no-console\n    });\n  }\n\n  /** JSDoc */\n  public warn(...args: any[]): void {\n    if (!this._enabled) {\n      return;\n    }\n    consoleSandbox(() => {\n      global.console.warn(`${PREFIX}[Warn]: ${args.join(' ')}`); // tslint:disable-line:no-console\n    });\n  }\n\n  /** JSDoc */\n  public error(...args: any[]): void {\n    if (!this._enabled) {\n      return;\n    }\n    consoleSandbox(() => {\n      global.console.error(`${PREFIX}[Error]: ${args.join(' ')}`); // tslint:disable-line:no-console\n    });\n  }\n}\n\n// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used\nglobal.__SENTRY__ = global.__SENTRY__ || {};\nconst logger = (global.__SENTRY__.logger as Logger) || (global.__SENTRY__.logger = new Logger());\n\nexport { logger };\n","import { isThenable } from './is';\n\n/** SyncPromise internal states */\nenum States {\n  /** Pending */\n  PENDING = 'PENDING',\n  /** Resolved / OK */\n  RESOLVED = 'RESOLVED',\n  /** Rejected / Error */\n  REJECTED = 'REJECTED',\n}\n\n/** JSDoc */\ninterface Handler<T, U> {\n  onFail: HandlerOnFail<U>;\n  onSuccess: HandlerOnSuccess<T, U>;\n}\n\ntype HandlerOnSuccess<T, U = any> = (value: T) => U | Thenable<U>;\ntype HandlerOnFail<U = any> = (reason: any) => U | Thenable<U>;\n\n/** JSDoc */\ninterface Thenable<T> {\n  /** JSDoc */\n  then<U>(onSuccess?: HandlerOnSuccess<T, U>, onFail?: HandlerOnFail<U> | ((reason: any) => void)): Thenable<U>;\n}\n\ntype Resolve<R> = (value?: R | Thenable<R> | any) => void;\ntype Reject = (value?: any) => void;\n\n/** JSDoc */\nexport class SyncPromise<T> implements PromiseLike<T> {\n  /** JSDoc */\n  private _state: States = States.PENDING;\n  /** JSDoc */\n  private _handlers: Array<Handler<T, any>> = [];\n  /** JSDoc */\n  private _value: T | any;\n\n  public constructor(callback: (resolve: Resolve<T>, reject: Reject) => void) {\n    try {\n      callback(this._resolve, this._reject);\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n\n  /** JSDoc */\n  private readonly _resolve = (value: T) => {\n    this._setResult(value, States.RESOLVED);\n  };\n\n  /** JSDoc */\n  private readonly _reject = (reason: any) => {\n    this._setResult(reason, States.REJECTED);\n  };\n\n  /** JSDoc */\n  private readonly _setResult = (value: T | any, state: States) => {\n    if (this._state !== States.PENDING) {\n      return;\n    }\n\n    if (isThenable(value)) {\n      (value as Thenable<T>).then(this._resolve, this._reject);\n      return;\n    }\n\n    this._value = value;\n    this._state = state;\n\n    this._executeHandlers();\n  };\n\n  /** JSDoc */\n  private readonly _executeHandlers = () => {\n    if (this._state === States.PENDING) {\n      return;\n    }\n\n    if (this._state === States.REJECTED) {\n      // tslint:disable-next-line:no-unsafe-any\n      this._handlers.forEach(h => h.onFail && h.onFail(this._value));\n    } else {\n      // tslint:disable-next-line:no-unsafe-any\n      this._handlers.forEach(h => h.onSuccess && h.onSuccess(this._value));\n    }\n\n    this._handlers = [];\n    return;\n  };\n\n  /** JSDoc */\n  private readonly _attachHandler = (handler: Handler<T, any>) => {\n    this._handlers = this._handlers.concat(handler);\n    this._executeHandlers();\n  };\n\n  /** JSDoc */\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined,\n  ): SyncPromise<TResult1 | TResult2> {\n    // public then<U>(onSuccess?: HandlerOnSuccess<T, U>, onFail?: HandlerOnFail<U>): SyncPromise<T | U> {\n    return new SyncPromise<TResult1 | TResult2>((resolve, reject) => {\n      this._attachHandler({\n        onFail: reason => {\n          if (!onrejected) {\n            reject(reason);\n            return;\n          }\n\n          try {\n            resolve(onrejected(reason));\n            return;\n          } catch (e) {\n            reject(e);\n            return;\n          }\n        },\n        onSuccess: result => {\n          if (!onfulfilled) {\n            resolve(result);\n            return;\n          }\n          try {\n            resolve(onfulfilled(result));\n            return;\n          } catch (e) {\n            reject(e);\n            return;\n          }\n        },\n      });\n    });\n  }\n\n  /** JSDoc */\n  public catch<U>(onFail: HandlerOnFail<U>): SyncPromise<U> {\n    // tslint:disable-next-line:no-unsafe-any\n    return this.then<U>((val: any) => val, onFail as any);\n  }\n\n  /** JSDoc */\n  public toString(): string {\n    return `[object SyncPromise]`;\n  }\n\n  /** JSDoc */\n  public static resolve<U>(value?: U | Thenable<U>): SyncPromise<U> {\n    return new SyncPromise<U>(resolve => {\n      resolve(value);\n    });\n  }\n\n  /** JSDoc */\n  public static reject<U>(reason?: any): SyncPromise<U> {\n    return new SyncPromise<U>((_, reject) => {\n      reject(reason);\n    });\n  }\n}\n","import { EventProcessor, Hub, Integration } from '@sentry/types';\nimport { getGlobalObject, supportsReportingObserver } from '@sentry/utils';\n\n/** JSDoc */\ninterface Report {\n  [key: string]: any;\n  type: ReportTypes;\n  url: string;\n  body?: ReportBody;\n}\n\n/** JSDoc */\nenum ReportTypes {\n  /** JSDoc */\n  Crash = 'crash',\n  /** JSDoc */\n  Deprecation = 'deprecation',\n  /** JSDoc */\n  Intervention = 'intervention',\n}\n\n/** JSDoc */\ntype ReportBody = CrashReportBody | DeprecationReportBody | InterventionReportBody;\n\n/** JSDoc */\ninterface CrashReportBody {\n  [key: string]: any;\n  crashId: string;\n  reason?: string;\n}\n\n/** JSDoc */\ninterface DeprecationReportBody {\n  [key: string]: any;\n  id: string;\n  anticipatedRemoval?: Date;\n  message: string;\n  sourceFile?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n}\n\n/** JSDoc */\ninterface InterventionReportBody {\n  [key: string]: any;\n  id: string;\n  message: string;\n  sourceFile?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n}\n\n/** Reporting API integration - https://w3c.github.io/reporting/ */\nexport class ReportingObserver implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public readonly name: string = ReportingObserver.id;\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'ReportingObserver';\n\n  /**\n   * Returns current hub.\n   */\n  private _getCurrentHub?: () => Hub;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(\n    private readonly _options: {\n      types?: ReportTypes[];\n    } = {\n      types: [ReportTypes.Crash, ReportTypes.Deprecation, ReportTypes.Intervention],\n    },\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    // tslint:disable:no-unsafe-any\n\n    if (!supportsReportingObserver()) {\n      return;\n    }\n\n    this._getCurrentHub = getCurrentHub;\n\n    const observer = new (getGlobalObject<any>()).ReportingObserver(this.handler.bind(this), {\n      buffered: true,\n      types: this._options.types,\n    });\n\n    observer.observe();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public handler(reports: Report[]): void {\n    const hub = this._getCurrentHub && this._getCurrentHub();\n    if (!hub || !hub.getIntegration(ReportingObserver)) {\n      return;\n    }\n    for (const report of reports) {\n      hub.withScope(scope => {\n        scope.setExtra('url', report.url);\n\n        const label = `ReportingObserver [${report.type}]`;\n        let details = 'No details available';\n\n        if (report.body) {\n          // Object.keys doesn't work on ReportBody, as all properties are inheirted\n          const plainBody: {\n            [key: string]: any;\n          } = {};\n\n          // tslint:disable-next-line:forin\n          for (const prop in report.body) {\n            plainBody[prop] = report.body[prop];\n          }\n\n          scope.setExtra('body', plainBody);\n\n          if (report.type === ReportTypes.Crash) {\n            const body = report.body as CrashReportBody;\n            // A fancy way to create a message out of crashId OR reason OR both OR fallback\n            details = [body.crashId || '', body.reason || ''].join(' ').trim() || details;\n          } else {\n            const body = report.body as DeprecationReportBody | InterventionReportBody;\n            details = body.message || details;\n          }\n        }\n\n        hub.captureMessage(`${label}: ${details}`);\n      });\n    }\n  }\n}\n","import { logger } from './logger';\nimport { getGlobalObject } from './misc';\n\n/**\n * Tells whether current environment supports ErrorEvent objects\n * {@link supportsErrorEvent}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsErrorEvent(): boolean {\n  try {\n    // tslint:disable:no-unused-expression\n    new ErrorEvent('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMError objects\n * {@link supportsDOMError}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsDOMError(): boolean {\n  try {\n    // It really needs 1 argument, not 0.\n    // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':\n    // 1 argument required, but only 0 present.\n    // @ts-ignore\n    // tslint:disable:no-unused-expression\n    new DOMError('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMException objects\n * {@link supportsDOMException}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsDOMException(): boolean {\n  try {\n    // tslint:disable:no-unused-expression\n    new DOMException('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports Fetch API\n * {@link supportsFetch}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsFetch(): boolean {\n  if (!('fetch' in getGlobalObject<Window>())) {\n    return false;\n  }\n\n  try {\n    // tslint:disable-next-line:no-unused-expression\n    new Headers();\n    // tslint:disable-next-line:no-unused-expression\n    new Request('');\n    // tslint:disable-next-line:no-unused-expression\n    new Response();\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports Fetch API natively\n * {@link supportsNativeFetch}.\n *\n * @returns true if `window.fetch` is natively implemented, false otherwise\n */\nexport function supportsNativeFetch(): boolean {\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  const isNativeFunc = (func: Function) => func.toString().indexOf('native') !== -1;\n  const global = getGlobalObject<Window>();\n  let result = null;\n  const doc = global.document;\n  if (doc) {\n    const sandbox = doc.createElement('iframe');\n    sandbox.hidden = true;\n    try {\n      doc.head.appendChild(sandbox);\n      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {\n        // tslint:disable-next-line no-unbound-method\n        result = isNativeFunc(sandbox.contentWindow.fetch);\n      }\n      doc.head.removeChild(sandbox);\n    } catch (err) {\n      logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);\n    }\n  }\n\n  if (result === null) {\n    // tslint:disable-next-line no-unbound-method\n    result = isNativeFunc(global.fetch);\n  }\n\n  return result;\n}\n\n/**\n * Tells whether current environment supports ReportingObserver API\n * {@link supportsReportingObserver}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsReportingObserver(): boolean {\n  // tslint:disable-next-line: no-unsafe-any\n  return 'ReportingObserver' in getGlobalObject();\n}\n\n/**\n * Tells whether current environment supports Referrer Policy API\n * {@link supportsReferrerPolicy}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsReferrerPolicy(): boolean {\n  // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default\n  // https://caniuse.com/#feat=referrer-policy\n  // It doesn't. And it throw exception instead of ignoring this parameter...\n  // REF: https://github.com/getsentry/raven-js/issues/1233\n\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  try {\n    // tslint:disable:no-unused-expression\n    new Request('_', {\n      referrerPolicy: 'origin' as ReferrerPolicy,\n    });\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports History API\n * {@link supportsHistory}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsHistory(): boolean {\n  // NOTE: in Chrome App environment, touching history.pushState, *even inside\n  //       a try/catch block*, will cause Chrome to output an error to console.error\n  // borrowed from: https://github.com/angular/angular.js/pull/13945/files\n  const global = getGlobalObject<Window>();\n  const chrome = (global as any).chrome;\n  // tslint:disable-next-line:no-unsafe-any\n  const isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;\n  const hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;\n\n  return !isChromePackagedApp && hasHistoryApi;\n}\n"],"names":["setPrototypeOf","Object","__proto__","Array","obj","proto","prop","hasOwnProperty","message","_super","_this","name","_newTarget","prototype","constructor","tslib_1.__extends","Error","fallbackGlobalObject","getGlobalObject","toString","call","process","global","window","self","consoleSandbox","callback","originalConsole","console","wrappedLevels","forEach","level","__sentry__","__sentry_wrapped__","__sentry_original__","result","keys","PREFIX","this","_enabled","Logger","_i","args","log","join","warn","error","__SENTRY__","States","ReportTypes","logger","_options","types","Crash","Deprecation","Intervention","ReportingObserver","id","_","getCurrentHub","_getCurrentHub","handler","bind","buffered","observe","reports","hub","getIntegration","report","withScope","scope","setExtra","url","label","type","details","body","plainBody","crashId","reason","trim","captureMessage","reports_1","tslib_1.__values"],"mappings":"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"}